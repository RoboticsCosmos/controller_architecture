append_vector_to_a_file_functions() ::= <<
// Function to append data to the file with dynamic size of vector
template \<size_t N>
void appendDataToFile_dynamic_size(std::ofstream &file, const std::vector\<std::array\<double, N>\> &data)
{
    for (const auto &row : data)
    {
        for (size_t i = 0; i \< N; ++i)
        {
            file \<\< row[i];
            if (i \< N - 1)
            {
                file \<\< ",";
            }
        }
        file \<\< "\n";
    }
}
>>


set_robots_to_control() ::= <<
    // set robots to control
    robot_controlled robots_to_control = robot_controlled::KINOVA_GEN3_1_LEFT;
>>


signal_interruption_handling_function() ::= <<
    // handling signals
    struct sigaction sa;
    sa.sa_handler = handle_signal;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = 0;

    for (int i = 1; i \< NSIG; ++i)
    {
        if (sigaction(i, &sa, NULL) == -1)
        {
            perror("sigaction");
        }
    }
>>


read_from_config_file_and_set_variables() ::= <<
    // initialise data by reading from the config file
    double TIMEOUT_DURATION_TASK; // in seconds
    double WRENCH_THRESHOLD_LINEAR;
    double WRENCH_THRESHOLD_ROTATIONAL;
    double JOINT_TORQUE_THRESHOLD;
    int SAVE_LOG_EVERY_NTH_STEP;
    double DESIRED_TIME_STEP;

    YAML::Node config_file = YAML::LoadFile("parameters.yaml");
    std::vector\<float> arm1_home = config_file["arm_1"]["home"].as\<std::vector\<float>\>();
    std::vector\<float> arm2_home = config_file["arm_2"]["home"].as\<std::vector\<float>\>();
    TIMEOUT_DURATION_TASK = config_file["TIMEOUT_DURATION_TASK"].as\<double>(); // seconds
    WRENCH_THRESHOLD_LINEAR = config_file["WRENCH_THRESHOLD_LINEAR"].as\<double>();
    WRENCH_THRESHOLD_ROTATIONAL = config_file["WRENCH_THRESHOLD_ROTATIONAL"].as\<double>();
    JOINT_TORQUE_THRESHOLD = config_file["JOINT_TORQUE_THRESHOLD"].as\<double>();
    SAVE_LOG_EVERY_NTH_STEP = config_file["SAVE_LOG_EVERY_NTH_STEP"].as\<int>();
    DESIRED_TIME_STEP = config_file["DESIRED_TIME_STEP"].as\<double>();
>>


initialise_logging_file_and_headers() ::= <<

    // logging
    std::string log_file_pid_investigation = "log_files/log_file_pid_investigation.csv";
    std::ofstream file_pid_investigation(log_file_pid_investigation);

    if (!file_pid_investigation.is_open())
    {
        std::cerr \<\< "Failed to open file: " \<\< log_file_pid_investigation \<\< std::endl;
        return 0;
    }
    // adding header
    file_pid_investigation \<\< "time_period_of_complete_controller_cycle_data,measured_lin_pos_z_axis_left_arm_data,measured_lin_vel_z_axis_left_arm_data,lin_vel_error_pid_z_axis_left_arm_data,p_term_lin_vel_z_axis_left_arm_data,d_term_lin_vel_error_z_axis_left_arm_data,d_term_lin_vel_z_axis_left_arm_data,integral_of_vel_term_error_z_axis_left_arm_data,i_term_lin_vel_z_axis_left_arm_data,apply_ee_force_z_axis_left_arm_data\n"; // header

    std::vector\<double> dataArray; // Vector to store data temporarily
    // initialise multi-dimensional array to store data
    std::vector\<std::array\<double, 10>\> data_pid_investigation;
    int iterationCount = 0;
>>


initialise_time_variables() ::= <<

    auto start_time_of_task = std::chrono::high_resolution_clock::now(); // start_time_of_task.count() gives time in seconds
    const auto task_time_out = std::chrono::duration\<double>(TIMEOUT_DURATION_TASK);
    auto previous_time = std::chrono::high_resolution_clock::now();
    auto time_elapsed = std::chrono::duration\<double>(previous_time - start_time_of_task);
>>


if_interrupt_signal_detected_write_rest_of_data_and_close_files() ::= <<

        // if any interruption (Ctrl+C or window resizing) is detected
        if (flag == 1)
        {
            // logging
            // Write remaining data to file
            if (!dataArray.empty())
            {
                // appendDataToFile(file, dataArray);
                appendDataToFile_dynamic_size(file_pid_investigation, data_pid_investigation);
                data_pid_investigation.clear();
            }

            // file.close();
            // file_ee_pose.close();
            file_pid_investigation.close();
            std::cout \<\< "Data collection completed.\n";
            break;
        }

>>


update_time_related_variables_in_while_loop() ::= <<
        // update the time variables
        auto current_time = std::chrono::high_resolution_clock::now();
        auto time_period = std::chrono::duration\<double>(current_time - previous_time);

        while (time_period.count() \< DESIRED_TIME_STEP)
        {
            current_time = std::chrono::high_resolution_clock::now();
            time_period = std::chrono::duration\<double>(current_time - previous_time);
        }

        time_elapsed = std::chrono::duration\<double>(current_time - start_time_of_task);
        previous_time = current_time;
        time_period_of_complete_controller_cycle_data = time_period.count();
        std::cout \<\< "time_period: " \<\< time_period_of_complete_controller_cycle_data \<\< std::endl;
>>


set_robot_feedback_to_corresponding_variables() ::= <<

        measured_lin_pos_x_axis_left_arm_data = measured_endEffPose_GF_left_arm.p.x();
        measured_lin_vel_x_axis_left_arm_data = measured_endEffTwist_GF_left_arm.GetTwist().vel.x();
        measured_lin_pos_y_axis_left_arm_data = measured_endEffPose_GF_left_arm.p.y();
        measured_lin_vel_y_axis_left_arm_data = measured_endEffTwist_GF_left_arm.GetTwist().vel.y();
        measured_lin_pos_z_axis_left_arm_data = measured_endEffPose_GF_left_arm.p.z();
        measured_lin_vel_z_axis_left_arm_data = measured_endEffTwist_GF_left_arm.GetTwist().vel.z();

        measured_lin_pos_x_axis_right_arm_data = measured_endEffPose_GF_right_arm.p.x();
        measured_lin_vel_x_axis_right_arm_data = measured_endEffTwist_GF_right_arm.GetTwist().vel.x();
        measured_lin_pos_y_axis_right_arm_data = measured_endEffPose_GF_right_arm.p.y();
        measured_lin_vel_y_axis_right_arm_data = measured_endEffTwist_GF_right_arm.GetTwist().vel.y();
        measured_lin_pos_z_axis_right_arm_data = measured_endEffPose_GF_right_arm.p.z();
        measured_lin_vel_z_axis_right_arm_data = measured_endEffTwist_GF_right_arm.GetTwist().vel.z();

>>


update_logging_arrays_and_add_to_file_if_sufficient_data_collected() ::= <<
        data_pid_investigation.push_back({time_period_of_complete_controller_cycle_data, measured_lin_pos_z_axis_left_arm_data, measured_lin_vel_z_axis_left_arm_data, lin_vel_error_pid_z_axis_left_arm_data, p_term_lin_vel_z_axis_left_arm_data, d_term_lin_vel_error_z_axis_left_arm_data, d_term_lin_vel_z_axis_left_arm_data, integral_of_vel_term_error_z_axis_left_arm_data, i_term_lin_vel_z_axis_left_arm_data, apply_ee_force_z_axis_left_arm_data});
        iterationCount++;
        // Check if we should write to file (every 100 iterations)
        if (iterationCount % SAVE_LOG_EVERY_NTH_STEP == 0)
        {
            appendDataToFile_dynamic_size(file_pid_investigation, data_pid_investigation);
            data_pid_investigation.clear();
        }
>>


save_remaining_data_before_exiting_the_program() ::= <<

    if (!dataArray.empty())
    {
        appendDataToFile_dynamic_size(file_pid_investigation, data_pid_investigation);
        data_pid_investigation.clear();
    }
    
    file_pid_investigation.close();
    std::cout \<\< "Data collection completed.\n";
>>
